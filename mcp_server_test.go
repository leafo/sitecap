package main

import (
	"context"
	"encoding/json"
	"sync"
	"testing"
	"time"

	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// setupTestServer creates a test MCP server instance
func setupTestServer() *mcp.Server {
	// Initialize global managers (same as in RunMCPServer)
	configManager = NewContextConfigManager()
	requestManager = NewRequestHistoryManager()
	cookieManager = NewCookieManager()

	// Create the MCP server
	server := mcp.NewServer(&mcp.Implementation{
		Name:    "sitecap-test",
		Version: "1.0.0-test",
	}, nil)

	// Register all tools
	registerTools(server)

	return server
}

// TestMCPServerInitialization tests that the server initializes correctly
func TestMCPServerInitialization(t *testing.T) {
	server := setupTestServer()

	if server == nil {
		t.Fatal("Server should not be nil")
	}

	// Verify that global managers are initialized
	if configManager == nil {
		t.Error("configManager should be initialized")
	}
	if requestManager == nil {
		t.Error("requestManager should be initialized")
	}
	if cookieManager == nil {
		t.Error("cookieManager should be initialized")
	}
}

// TestMCPServerToolsList tests the tools/list endpoint using proper MCP client-server communication
func TestMCPServerToolsList(t *testing.T) {
	// Create in-memory transports for testing
	serverTransport, clientTransport := mcp.NewInMemoryTransports()

	// Setup test server
	server := setupTestServer()

	// Run server in background
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		defer wg.Done()
		err := server.Run(ctx, serverTransport)
		if err != nil && err != context.Canceled {
			t.Errorf("Server run error: %v", err)
		}
	}()

	// Create client and connect to server
	client := mcp.NewClient(&mcp.Implementation{
		Name:    "test-client",
		Version: "1.0.0",
	}, nil)

	session, err := client.Connect(ctx, clientTransport, nil)
	if err != nil {
		t.Fatalf("Failed to connect client to server: %v", err)
	}
	defer session.Close()

	// Call tools/list
	toolsResult, err := session.ListTools(ctx, &mcp.ListToolsParams{})

	toolsJSON, err := json.MarshalIndent(toolsResult, "", "  ")
	if err != nil {
		t.Fatalf("Failed to serialize tools result: %v", err)
	}
	t.Logf("Tools List Result: %s", toolsJSON)

	if err != nil {
		t.Fatalf("ListTools failed: %v", err)
	}

	// Verify all expected tools are present
	expectedTools := map[string]string{
		"configure_context": "Configure browser settings for a named context",
		"list_contexts":     "List all browser contexts",
		"screenshot":        "Take a screenshot of a webpage",
		"get_html":          "Get rendered HTML content from a webpage",
	}

	if len(toolsResult.Tools) != len(expectedTools) {
		t.Errorf("Expected %d tools, got %d", len(expectedTools), len(toolsResult.Tools))
	}

	// Check each tool
	foundTools := make(map[string]bool)
	for _, tool := range toolsResult.Tools {
		foundTools[tool.Name] = true

		expectedDesc, exists := expectedTools[tool.Name]
		if !exists {
			t.Errorf("Unexpected tool: %s", tool.Name)
			continue
		}

		if tool.Description != expectedDesc {
			t.Errorf("Tool %s: expected description %q, got %q", tool.Name, expectedDesc, tool.Description)
		}

		if tool.Name == "" {
			t.Errorf("Tool name should not be empty")
		}

		// Verify tool has input schema (should be auto-generated by AddTool)
		if tool.InputSchema == nil {
			t.Errorf("Tool %s should have input schema", tool.Name)
		}
	}

	// Verify all expected tools were found
	for expectedTool := range expectedTools {
		if !foundTools[expectedTool] {
			t.Errorf("Expected tool not found: %s", expectedTool)
		}
	}

	// Stop server
	cancel()
	wg.Wait()
}

// TestMCPServerToolsSchema tests that tools have proper schema information
func TestMCPServerToolsSchema(t *testing.T) {
	// This test focuses on the structure without requiring a full server run
	server := setupTestServer()

	if server == nil {
		t.Fatal("Server should not be nil")
	}

	// Test that registerTools doesn't panic and creates expected structure
	// This is a structural test since we can't easily intercept the internal tool registration

	// Verify expected tool names match what's registered in registerTools function
	expectedTools := []string{
		"configure_context",
		"list_contexts",
		"screenshot",
		"get_html",
	}

	// This test validates the structure we expect based on the registerTools function
	for _, toolName := range expectedTools {
		// Each tool should have a non-empty name and description
		// The actual validation happens in the integration test above
		if toolName == "" {
			t.Errorf("Tool name should not be empty")
		}
	}

	t.Log("Tool schema structure test completed successfully")
}

// TestRegisterToolsFunction tests the registerTools function directly
func TestRegisterToolsFunction(t *testing.T) {
	server := setupTestServer()

	// Test that registerTools doesn't panic
	defer func() {
		if r := recover(); r != nil {
			t.Errorf("registerTools panicked: %v", r)
		}
	}()

	// Call registerTools again to ensure it's idempotent
	registerTools(server)

	t.Log("registerTools function executed without panic")
}

// TestMCPServerManagersInitialization tests manager initialization
func TestMCPServerManagersInitialization(t *testing.T) {
	// Save original managers
	originalConfig := configManager
	originalRequest := requestManager
	originalCookie := cookieManager

	// Reset managers
	configManager = nil
	requestManager = nil
	cookieManager = nil

	// Test initialization
	setupTestServer()

	// Verify managers are created
	if configManager == nil {
		t.Error("configManager should be initialized")
	}
	if requestManager == nil {
		t.Error("requestManager should be initialized")
	}
	if cookieManager == nil {
		t.Error("cookieManager should be initialized")
	}

	// Test manager functionality
	if configManager != nil {
		contexts := configManager.ListContexts()
		if contexts == nil {
			t.Error("ListContexts should return a non-nil map")
		}
	}

	if requestManager != nil {
		// Test that we can store and retrieve a request
		testRequest := &StoredRequest{
			ID:          "test-id",
			ContextName: "test-context",
			URL:         "https://example.com",
		}
		requestManager.StoreRequest(testRequest)

		retrieved, exists := requestManager.GetRequest("test-id")
		if !exists {
			t.Error("Should be able to retrieve stored request")
		}
		if retrieved.ID != "test-id" {
			t.Error("Retrieved request should have correct ID")
		}
	}

	// Restore original managers
	configManager = originalConfig
	requestManager = originalRequest
	cookieManager = originalCookie
}
