package main

import (
	"context"
	"encoding/json"
	"fmt"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/go-rod/rod/lib/proto"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// saveTestScreenshot saves a screenshot to the test results directory if the environment variable is set
func saveTestScreenshot(t *testing.T, screenshotData []byte) {
	// Check if we should save screenshots to disk for manual inspection
	if saveScreenshots := os.Getenv("SITECAP_SAVE_TEST_SCREENSHOTS"); saveScreenshots != "" {
		// Create test results directory
		testResultsDir := "test_results"
		if err := os.MkdirAll(testResultsDir, 0755); err != nil {
			t.Logf("Warning: Failed to create test results directory: %v", err)
			return
		}

		// Save screenshot to disk using test name
		screenshotPath := filepath.Join(testResultsDir, t.Name()+".png")
		if err := os.WriteFile(screenshotPath, screenshotData, 0644); err != nil {
			t.Logf("Warning: Failed to save screenshot to %s: %v", screenshotPath, err)
		} else {
			t.Logf("Screenshot saved to %s for manual inspection", screenshotPath)
		}
	}
}

// setupTestServer creates a test MCP server instance
func setupTestServer() *mcp.Server {
	// Initialize global managers (same as in RunMCPServer)
	configManager = NewContextConfigManager()
	requestManager = NewRequestHistoryManager()

	// Create the MCP server
	server := mcp.NewServer(&mcp.Implementation{
		Name:    "sitecap-test",
		Version: "1.0.0-test",
	}, nil)

	registerTools(server)

	return server
}

// TestMCPServerInitialization tests that the server initializes correctly
func TestMCPServerInitialization(t *testing.T) {
	server := setupTestServer()

	if server == nil {
		t.Fatal("Server should not be nil")
	}

	// Verify that global managers are initialized
	if configManager == nil {
		t.Error("configManager should be initialized")
	}
	if requestManager == nil {
		t.Error("requestManager should be initialized")
	}
}

// TestMCPServerToolsList tests the tools/list endpoint using proper MCP client-server communication
func TestMCPServerToolsList(t *testing.T) {
	// Create in-memory transports for testing
	serverTransport, clientTransport := mcp.NewInMemoryTransports()

	// Setup test server
	server := setupTestServer()

	// Run server in background
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		defer wg.Done()
		err := server.Run(ctx, serverTransport)
		if err != nil && err != context.Canceled {
			t.Errorf("Server run error: %v", err)
		}
	}()

	// Create client and connect to server
	client := mcp.NewClient(&mcp.Implementation{
		Name:    "test-client",
		Version: "1.0.0",
	}, nil)

	session, err := client.Connect(ctx, clientTransport, nil)
	if err != nil {
		t.Fatalf("Failed to connect client to server: %v", err)
	}
	defer session.Close()

	// Call tools/list
	toolsResult, err := session.ListTools(ctx, &mcp.ListToolsParams{})

	toolsJSON, err := json.MarshalIndent(toolsResult, "", "  ")
	if err != nil {
		t.Fatalf("Failed to serialize tools result: %v", err)
	}
	t.Logf("Tools List Result: %s", toolsJSON)

	if err != nil {
		t.Fatalf("ListTools failed: %v", err)
	}

	// Verify all expected tools are present
	expectedTools := map[string]string{
		"configure_context": "Configure browser settings for a named context",
		"list_contexts":     "List all browser contexts",
		"screenshot_url":    "Take a screenshot of a webpage from URL",
		"screenshot_html":   "Take a screenshot by rendering arbitrary HTML content",
		"get_html":          "Get rendered HTML content from a webpage",
		"get_last_request":  "Get details about the last request made in a browser context",
	}

	if len(toolsResult.Tools) != len(expectedTools) {
		t.Errorf("Expected %d tools, got %d", len(expectedTools), len(toolsResult.Tools))
	}

	// Check each tool
	foundTools := make(map[string]bool)
	for _, tool := range toolsResult.Tools {
		foundTools[tool.Name] = true

		expectedDesc, exists := expectedTools[tool.Name]
		if !exists {
			t.Errorf("Unexpected tool: %s", tool.Name)
			continue
		}

		if tool.Description != expectedDesc {
			t.Errorf("Tool %s: expected description %q, got %q", tool.Name, expectedDesc, tool.Description)
		}

		if tool.Name == "" {
			t.Errorf("Tool name should not be empty")
		}

		// Verify tool has input schema (should be auto-generated by AddTool)
		if tool.InputSchema == nil {
			t.Errorf("Tool %s should have input schema", tool.Name)
		}
	}

	// Verify all expected tools were found
	for expectedTool := range expectedTools {
		if !foundTools[expectedTool] {
			t.Errorf("Expected tool not found: %s", expectedTool)
		}
	}

	// Stop server
	cancel()
	wg.Wait()
}

// TestHTTPServer creates a test HTTP server that sets cookies
func createTestHTTPServer(t *testing.T) (string, func()) {
	// Create listener on random port
	listener, err := net.Listen("tcp", ":0")
	if err != nil {
		t.Fatalf("Failed to create listener: %v", err)
	}

	port := listener.Addr().(*net.TCPAddr).Port
	baseURL := fmt.Sprintf("http://localhost:%d", port)

	// Create HTTP server with cookie-setting endpoints
	mux := http.NewServeMux()

	// Page that renders the cookies
	mux.HandleFunc("/cookies", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/html")
		fmt.Fprint(w, "<!DOCTYPE html><html><head><title>Cookies Page</title></head><body><h1>Cookies</h1><ul>")
		for _, cookie := range r.Cookies() {
			fmt.Fprintf(w, "<li>%s: %s</li>", cookie.Name, cookie.Value)
		}
		fmt.Fprint(w, "</ul></body></html>")
	})

	// Main page that sets cookies
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		// Set multiple cookies using both http.SetCookie and raw headers to ensure they appear
		http.SetCookie(w, &http.Cookie{
			Name:     "session_id",
			Value:    "abc123xyz",
			Path:     "/",
			Domain:   "localhost",
			HttpOnly: true,
		})

		http.SetCookie(w, &http.Cookie{
			Name:   "user_pref",
			Value:  "dark_mode",
			Path:   "/",
			Domain: "localhost",
		})

		http.SetCookie(w, &http.Cookie{
			Name:   "analytics",
			Value:  "enabled",
			Path:   "/analytics",
			Domain: "localhost",
		})

		// Also add raw Set-Cookie headers to be absolutely sure they appear
		w.Header().Add("Set-Cookie", "test_cookie=test_value; Path=/; Domain=localhost")
		w.Header().Add("Set-Cookie", "another_cookie=another_value; Path=/; Domain=localhost")

		// Return HTML content
		html := `<!DOCTYPE html>
<html>
<head>
    <title>Test Page with Cookies</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .cookie-info { background: #f0f0f0; padding: 20px; margin: 20px 0; }
        #status { color: green; font-weight: bold; }
    </style>
</head>
<body>
    <h1>Cookie Test Page</h1>
    <div class="cookie-info">
        <h2>Cookies Set</h2>
        <ul>
            <li>session_id=abc123xyz (HttpOnly, Domain=localhost, Path=/)</li>
            <li>user_pref=dark_mode (Domain=localhost, Path=/)</li>
            <li>analytics=enabled (Domain=localhost, Path=/analytics)</li>
        </ul>
    </div>
    <div id="status">✓ Page loaded successfully with cookies</div>
    <script>
        // Add some dynamic content to verify JavaScript execution
        document.addEventListener('DOMContentLoaded', function() {
            const status = document.getElementById('status');
            status.textContent = '✓ JavaScript executed and cookies set';
        });
    </script>
</body>
</html>`

		w.Header().Set("Content-Type", "text/html")
		fmt.Fprint(w, html)
	})

	// Start server in goroutine
	server := &http.Server{Handler: mux}
	go func() {
		server.Serve(listener)
	}()

	// Return cleanup function
	cleanup := func() {
		server.Close()
		listener.Close()
	}

	return baseURL, cleanup
}

func TestMCPServerHTMLToScreenshot(t *testing.T) {
	// Create test HTTP server
	serverURL, cleanup := createTestHTTPServer(t)
	defer cleanup()

	// Wait briefly for server to be ready
	time.Sleep(100 * time.Millisecond)

	// Create HTML content that references our test server (simulating external resource)
	htmlContent := fmt.Sprintf(`<!DOCTYPE html>
<html>
<head>
    <title>HTML Screenshot Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .test-container { background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .server-info { background: #e3f2fd; padding: 15px; margin: 15px 0; border-radius: 4px; }
    </style>
</head>
<body>
    <h1>MCP HTML Screenshot Test</h1>
    <p>Test server running at: %s</p>
    <p>Current timestamp: <span id="timestamp"><strong>TO BE REPLACED BY JAVASCRIPT</strong></span></p>
    <script>
        document.getElementById('timestamp').textContent = new Date().toISOString();
    </script>
</body>
</html>`, serverURL)

	// Setup MCP server for testing
	serverTransport, clientTransport := mcp.NewInMemoryTransports()
	server := setupTestServer()

	// Run server in background
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		defer wg.Done()
		err := server.Run(ctx, serverTransport)
		if err != nil && err != context.Canceled {
			t.Errorf("Server run error: %v", err)
		}
	}()

	// Create client and connect to server
	client := mcp.NewClient(&mcp.Implementation{
		Name:    "test-client",
		Version: "1.0.0",
	}, nil)

	session, err := client.Connect(ctx, clientTransport, nil)
	if err != nil {
		t.Fatalf("Failed to connect client to server: %v", err)
	}
	defer session.Close()

	// render the HTML to screenshot using default context
	result, err := session.CallTool(ctx, &mcp.CallToolParams{
		Name: "screenshot_html",
		Arguments: map[string]interface{}{
			"html_content": htmlContent,
		},
	})

	if err != nil {
		t.Fatalf("screenshot_html tool call failed: %v", err)
	}

	// Verify the response structure
	if len(result.Content) == 0 {
		t.Fatal("Expected response content, got empty")
	}

	// Check that we got a text content response
	content := result.Content[0]
	if textContent, ok := content.(*mcp.TextContent); ok {
		// The result should be a success message, not the actual image data
		// The image data is stored in the request history, not returned directly
		if !strings.Contains(textContent.Text, "successfully") {
			t.Errorf("Expected success message, got: %s", textContent.Text)
		}
	} else {
		t.Fatal("Expected TextContent response from screenshot_html")
	}

	testContextName := "default" // screenshot_html used default context
	context, exists := configManager.GetContext(testContextName)
	if !exists {
		t.Fatal("Expected test context to exist after screenshot_html call")
	}

	// Verify context has request history
	if context.LastRequestID == "" {
		t.Error("Expected LastRequestID to be set after screenshot_html call")
	}

	if len(context.RequestHistory) == 0 {
		t.Error("Expected request history to be populated")
	}

	// Verify the stored request contains the expected data
	lastRequest, exists := requestManager.GetRequest(context.LastRequestID)

	if !exists {
		t.Fatal("Expected to find stored request in request manager")
	}

	if lastRequest.RequestType != "screenshot_html" {
		t.Errorf("Expected request type 'screenshot_html', got %s", lastRequest.RequestType)
	}

	if lastRequest.ContextName != testContextName {
		t.Errorf("Expected context name %s, got %s", testContextName, lastRequest.ContextName)
	}

	// Check for HTML content in stored request
	if lastRequest.Response == nil || lastRequest.Response.HTML == nil || *lastRequest.Response.HTML == "" {
		t.Error("Expected HTML content to be stored in request")
	}

	// Verify screenshot data is stored
	if lastRequest.Response == nil || len(lastRequest.Response.Screenshot) == 0 {
		t.Error("Expected screenshot data to be stored in request")
	} else {
		// Save screenshot to disk if environment variable is set
		saveTestScreenshot(t, lastRequest.Response.Screenshot)
	}

	// Stop server
	cancel()
	wg.Wait()
}

// TestMCPServerCookieUpdates tests the update_cookies functionality with actual HTTP requests
func TestMCPServerCookieUpdates(t *testing.T) {
	// Create test HTTP server that sets cookies
	serverURL, cleanup := createTestHTTPServer(t)
	defer cleanup()

	// Wait briefly for server to be ready
	time.Sleep(100 * time.Millisecond)

	// Setup MCP server for testing
	serverTransport, clientTransport := mcp.NewInMemoryTransports()
	server := setupTestServer()

	// Run server in background
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		defer wg.Done()
		err := server.Run(ctx, serverTransport)
		if err != nil && err != context.Canceled {
			t.Errorf("Server run error: %v", err)
		}
	}()

	// Create client and connect to server
	client := mcp.NewClient(&mcp.Implementation{
		Name:    "test-client",
		Version: "1.0.0",
	}, nil)

	session, err := client.Connect(ctx, clientTransport, nil)
	if err != nil {
		t.Fatalf("Failed to connect client to server: %v", err)
	}
	defer session.Close()

	result, err := session.CallTool(ctx, &mcp.CallToolParams{
		Name: "screenshot_url",
		Arguments: map[string]interface{}{
			"url":            serverURL,
			"update_cookies": true,
		},
	})

	if err != nil {
		t.Fatalf("screenshot_url tool call failed: %v", err)
	}

	// Verify successful response
	if len(result.Content) == 0 {
		t.Fatal("Expected response content, got empty")
	}

	if textContent, ok := result.Content[0].(*mcp.TextContent); ok {
		if !strings.Contains(textContent.Text, "successfully") {
			t.Errorf("Expected success message, got: %s", textContent.Text)
		}
	} else {
		t.Fatal("Expected TextContent response from screenshot_url")
	}

	// Verify that cookies were updated in the context
	contextName := "default"
	context, exists := configManager.GetContext(contextName)

	if !exists {
		t.Fatal("missing default context")
	}

	// Verify the last request object contains the cookies
	lastRequest, exists := requestManager.GetRequest(context.LastRequestID)
	if !exists {
		t.Fatal("Expected to find stored request in request manager")
	}

	if lastRequest.Response == nil {
		t.Fatal("Expected response data in stored request")
	}

	// Verify the captured cookies from the browser response
	// Note: Only cookies with path "/" or that match the current path will be captured
	// The analytics cookie with path="/analytics" won't be included since we're visiting "/"
	expectedCookies := []struct {
		name     string
		value    string
		domain   string
		path     string
		httpOnly bool
	}{
		{"session_id", "abc123xyz", "localhost", "/", true},
		{"user_pref", "dark_mode", "localhost", "/", false},
		{"test_cookie", "test_value", "localhost", "/", false},
		{"another_cookie", "another_value", "localhost", "/", false},
	}

	if len(lastRequest.Response.Cookies) != len(expectedCookies) {
		t.Errorf("Expected %d cookies in response, got %d", len(expectedCookies), len(lastRequest.Response.Cookies))
	}

	// Verify each expected cookie is present in the response
	cookieMap := make(map[string]*proto.NetworkCookie)
	for _, cookie := range lastRequest.Response.Cookies {
		cookieMap[cookie.Name] = cookie
	}

	for _, expected := range expectedCookies {
		cookie, found := cookieMap[expected.name]
		if !found {
			t.Errorf("Expected cookie %s not found in response", expected.name)
			continue
		}

		if cookie.Value != expected.value {
			t.Errorf("Cookie %s: expected value %s, got %s", expected.name, expected.value, cookie.Value)
		}

		if cookie.Domain != expected.domain {
			t.Errorf("Cookie %s: expected domain %s, got %s", expected.name, expected.domain, cookie.Domain)
		}

		if cookie.Path != expected.path {
			t.Errorf("Cookie %s: expected path %s, got %s", expected.name, expected.path, cookie.Path)
		}

		if cookie.HTTPOnly != expected.httpOnly {
			t.Errorf("Cookie %s: expected httpOnly %v, got %v", expected.name, expected.httpOnly, cookie.HTTPOnly)
		}
	}

	// Verify context.Cookies has been updated with the resulting cookies
	if len(context.Cookies) == 0 {
		t.Fatal("Expected context cookies to be updated, but got empty slice")
	}

	// Create a map of context cookies for easier verification
	contextCookieMap := make(map[string]*proto.NetworkCookieParam)
	for _, cookie := range context.Cookies {
		contextCookieMap[cookie.Name] = cookie
	}

	// Verify each expected cookie is present in the context
	for _, expected := range expectedCookies {
		contextCookie, found := contextCookieMap[expected.name]
		if !found {
			t.Errorf("Expected cookie %s not found in context cookies", expected.name)
			continue
		}

		if contextCookie.Value != expected.value {
			t.Errorf("Context cookie %s: expected value %s, got %s", expected.name, expected.value, contextCookie.Value)
		}

		if contextCookie.Domain != expected.domain {
			t.Errorf("Context cookie %s: expected domain %s, got %s", expected.name, expected.domain, contextCookie.Domain)
		}

		if contextCookie.Path != expected.path {
			t.Errorf("Context cookie %s: expected path %s, got %s", expected.name, expected.path, contextCookie.Path)
		}

		if contextCookie.HTTPOnly != expected.httpOnly {
			t.Errorf("Context cookie %s: expected httpOnly %v, got %v", expected.name, expected.httpOnly, contextCookie.HTTPOnly)
		}
	}

	// Stop server
	cancel()
	wg.Wait()
}

// TestMCPServerContextCookieTransmission tests that context cookies are properly sent to the test server
func TestMCPServerContextCookieTransmission(t *testing.T) {
	// Create test HTTP server that can display received cookies
	serverURL, cleanup := createTestHTTPServer(t)
	defer cleanup()

	// Wait briefly for server to be ready
	time.Sleep(100 * time.Millisecond)

	// Setup MCP server for testing
	serverTransport, clientTransport := mcp.NewInMemoryTransports()
	server := setupTestServer()

	// Run server in background
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		defer wg.Done()
		err := server.Run(ctx, serverTransport)
		if err != nil && err != context.Canceled {
			t.Errorf("Server run error: %v", err)
		}
	}()

	// Create client and connect to server
	client := mcp.NewClient(&mcp.Implementation{
		Name:    "test-client",
		Version: "1.0.0",
	}, nil)

	session, err := client.Connect(ctx, clientTransport, nil)
	if err != nil {
		t.Fatalf("Failed to connect client to server: %v", err)
	}
	defer session.Close()

	// Configure a test context with predefined cookies
	testContextName := "cookie_test_context"
	configArgs := map[string]interface{}{
		"context_name": testContextName,
		"viewport":     "1280x720",
		"timeout":      20,
		"cookies": []map[string]interface{}{
			{
				"name":   "auth_token",
				"value":  "xyz123",
				"domain": "localhost",
				"path":   "/",
			},
			{
				"name":   "user_id",
				"value":  "456",
				"domain": "localhost",
				"path":   "/",
			},
			{
				"name":   "session",
				"value":  "active",
				"domain": "localhost",
				"path":   "/",
			},
		},
	}

	_, err = session.CallTool(ctx, &mcp.CallToolParams{
		Name:      "configure_context",
		Arguments: configArgs,
	})
	if err != nil {
		t.Fatalf("configure_context tool call failed: %v", err)
	}

	// Make a screenshot request to the /cookies endpoint using the configured context
	result, err := session.CallTool(ctx, &mcp.CallToolParams{
		Name: "screenshot_url",
		Arguments: map[string]interface{}{
			"url":          serverURL + "/cookies",
			"context_name": testContextName,
		},
	})

	if err != nil {
		t.Fatalf("screenshot_url tool call failed: %v", err)
	}

	// Verify successful response
	if len(result.Content) == 0 {
		t.Fatal("Expected response content, got empty")
	}

	if textContent, ok := result.Content[0].(*mcp.TextContent); ok {
		if !strings.Contains(textContent.Text, "successfully") {
			t.Errorf("Expected success message, got: %s", textContent.Text)
		}
	} else {
		t.Fatal("Expected TextContent response from screenshot_url")
	}

	// Get the context and verify the request was made
	context, exists := configManager.GetContext(testContextName)
	if !exists {
		t.Fatal("Expected test context to exist")
	}

	// Get the last request to verify HTML content
	lastRequest, exists := requestManager.GetRequest(context.LastRequestID)
	if !exists {
		t.Fatal("Expected to find stored request in request manager")
	}

	if lastRequest.Response == nil || lastRequest.Response.HTML == nil {
		t.Fatal("Expected HTML content in response")
	}

	// Parse the HTML from the /cookies endpoint to verify our cookies were sent
	htmlContent := *lastRequest.Response.HTML
	t.Logf("Received HTML from /cookies endpoint:\n%s", htmlContent)

	// Expected cookies that should appear in the HTML
	expectedCookies := []struct {
		name  string
		value string
	}{
		{"auth_token", "xyz123"},
		{"user_id", "456"},
		{"session", "active"},
	}

	// Verify each expected cookie appears in the HTML
	for _, expected := range expectedCookies {
		expectedPattern := fmt.Sprintf("<li>%s: %s</li>", expected.name, expected.value)
		if !strings.Contains(htmlContent, expectedPattern) {
			t.Errorf("Expected cookie pattern %q not found in HTML content", expectedPattern)
		}
	}

	// Also verify that the page shows the expected structure
	if !strings.Contains(htmlContent, "<h1>Cookies</h1>") {
		t.Error("Expected cookies page header not found")
	}

	// Stop server
	cancel()
	wg.Wait()
}
